---
name: "üöÄ Master CI/CD Pipeline"

"on":
  push:
    branches:
      - main
      - develop
  pull_request:
    branches:
      - main
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - dev
          - qa
          - prod
        default: 'dev'
      skip_terraform:
        description: 'Skip infrastructure deployment'
        type: boolean
        default: false
      skip_security:
        description: 'Skip security scans (NOT recommended for prod)'
        type: boolean
        default: false
      skip_deploy:
        description: 'Skip application deployment (infrastructure only)'
        type: boolean
        default: false
      force_build_all:
        description: 'Force build all services (ignore change detection)'
        type: boolean
        default: false

permissions:
  contents: read
  security-events: write
  pull-requests: write
  id-token: write
  actions: read

env:
  AWS_REGION: eu-west-2
  CLUSTER_NAME: microservices

jobs:
  # ============================================================================
  # STAGE 0: Pipeline Initialization
  # ============================================================================

  pipeline-init:
    name: "üéØ Pipeline Initialization"
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      should_deploy: ${{ steps.set-env.outputs.should_deploy }}
      is_production: ${{ steps.set-env.outputs.is_production }}

    steps:
      - name: Determine Environment
        id: set-env
        run: |
          # Determine environment based on trigger
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            ENV="${{ github.event.inputs.environment }}"
          elif [ "${{ github.ref }}" == "refs/heads/main" ]; then
            ENV="dev"  # Auto-deploy to dev on main
          elif [ "${{ github.ref }}" == "refs/heads/develop" ]; then
            ENV="dev"
          else
            ENV="dev"  # Default for PRs
          fi

          echo "environment=$ENV" >> $GITHUB_OUTPUT

          # Determine if we should deploy (not on PRs unless explicitly requested)
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          else
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          fi

          # Flag production deployments
          if [ "$ENV" == "prod" ]; then
            echo "is_production=true" >> $GITHUB_OUTPUT
          else
            echo "is_production=false" >> $GITHUB_OUTPUT
          fi

          echo "## üéØ Pipeline Configuration" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Parameter | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | **$ENV** |" >> $GITHUB_STEP_SUMMARY
          echo "| Trigger | ${{ github.event_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Branch | \`${{ github.ref_name }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Actor | @${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Commit | [\`${{ github.sha }}\`](${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }}) |" >> $GITHUB_STEP_SUMMARY

  # ============================================================================
  # STAGE 1: Code Quality & Security (Parallel Execution)
  # ============================================================================

  validate-code:
    name: "üìã Code Validation"
    runs-on: ubuntu-latest
    if: ${{ !inputs.skip_security }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Validate Kustomize Configurations
        run: |
          echo "### üìã Kustomize Validation" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          for env in dev qa prod; do
            echo "Validating kustomize/overlays/$env..."
            if kubectl kustomize kustomize/overlays/$env > /dev/null 2>&1; then
              echo "‚úÖ $env overlay valid" >> $GITHUB_STEP_SUMMARY
            else
              echo "‚ùå $env overlay INVALID" >> $GITHUB_STEP_SUMMARY
              exit 1
            fi
          done

      - name: YAML Lint
        run: |
          # Install yamllint if not present
          if ! command -v yamllint &> /dev/null; then
            pip install yamllint
          fi
          yamllint -d "{extends: default, rules: {line-length: {max: 400}, comments: disable}}" .github/workflows/ || true

  security-scans:
    name: "üîí Security Scanning"
    needs: pipeline-init
    if: ${{ !inputs.skip_security }}
    uses: ./.github/workflows/security-scan.yaml
    secrets: inherit

  # ============================================================================
  # STAGE 2: Infrastructure Management (Conditional)
  # ============================================================================

  detect-terraform-changes:
    name: "üîç Detect Infrastructure Changes"
    runs-on: ubuntu-latest
    outputs:
      terraform_changed: ${{ steps.filter.outputs.terraform }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Check for Terraform Changes
        uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            terraform:
              - 'terraform-aws/**'
              - '.github/workflows/MASTER-PIPELINE.yaml'
              - '.github/workflows/terraform-*.yaml'

  terraform-plan:
    name: "üìä Terraform Plan"
    needs: [pipeline-init, detect-terraform-changes]
    if: |
      needs.detect-terraform-changes.outputs.terraform_changed == 'true' &&
      !inputs.skip_terraform
    uses: ./.github/workflows/terraform-plan.yaml
    secrets: inherit
    with:
      environment: ${{ needs.pipeline-init.outputs.environment }}

  terraform-apply:
    name: "üèóÔ∏è Deploy Infrastructure"
    needs: [pipeline-init, terraform-plan, security-scans]
    if: |
      needs.detect-terraform-changes.outputs.terraform_changed == 'true' &&
      !inputs.skip_terraform &&
      github.ref == 'refs/heads/main' &&
      github.event_name != 'pull_request'
    uses: ./.github/workflows/terraform-apply.yaml
    secrets: inherit
    with:
      environment: ${{ needs.pipeline-init.outputs.environment }}
      action: 'apply'

  # ============================================================================
  # STAGE 3: Build Docker Images (Smart Change Detection)
  # ============================================================================

  detect-service-changes:
    name: "üîç Detect Service Changes"
    runs-on: ubuntu-latest
    outputs:
      services_changed: ${{ steps.filter.outputs.changes }}
      has_changes: ${{ steps.check.outputs.has_changes }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Detect Changed Services
        uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            frontend: 'src/frontend/**'
            cartservice: 'src/cartservice/**'
            productcatalogservice: 'src/productcatalogservice/**'
            currencyservice: 'src/currencyservice/**'
            paymentservice: 'src/paymentservice/**'
            shippingservice: 'src/shippingservice/**'
            emailservice: 'src/emailservice/**'
            checkoutservice: 'src/checkoutservice/**'
            recommendationservice: 'src/recommendationservice/**'
            adservice: 'src/adservice/**'
            loadgenerator: 'src/loadgenerator/**'
            shoppingassistantservice: 'src/shoppingassistantservice/**'

      - name: Check if Any Services Changed
        id: check
        run: |
          CHANGES='${{ steps.filter.outputs.changes }}'
          if [ "${{ inputs.force_build_all }}" == "true" ]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "üî® Force build enabled - will build all services"
          elif [ "$CHANGES" != "" ] && [ "$CHANGES" != "[]" ]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "üì¶ Detected changes in: $CHANGES"
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è No service changes detected"
          fi

  build-and-push:
    name: "üê≥ Build Docker Images"
    needs: [pipeline-init, detect-service-changes, security-scans]
    if: |
      needs.detect-service-changes.outputs.has_changes == 'true' ||
      inputs.force_build_all
    uses: ./.github/workflows/build-images.yaml
    secrets: inherit
    with:
      environment: ${{ needs.pipeline-init.outputs.environment }}
      services: ${{ inputs.force_build_all && 'all' || needs.detect-service-changes.outputs.services_changed }}
      push_images: ${{ github.event_name != 'pull_request' }}

  # ============================================================================
  # STAGE 4: ServiceNow Change Management (Production Gate)
  # ============================================================================

  create-change-request:
    name: "üìã ServiceNow Change Management"
    needs: [pipeline-init, security-scans, build-and-push]
    # CRITICAL: Run even if Terraform fails! ServiceNow integration should proceed
    # as long as security scans and image builds succeeded. This ensures:
    # 1. Security tools are registered in ServiceNow (with change context)
    # 2. Change requests are created even for failed infrastructure deployments
    # 3. Audit trail is complete regardless of deployment outcome
    if: |
      always() &&
      needs.pipeline-init.outputs.should_deploy == 'true' &&
      !inputs.skip_deploy &&
      github.event_name != 'pull_request' &&
      (needs.security-scans.result == 'success' || needs.security-scans.result == 'skipped') &&
      (needs.build-and-push.result == 'success' || needs.build-and-push.result == 'skipped')
    uses: ./.github/workflows/servicenow-integration.yaml
    secrets: inherit
    with:
      environment: ${{ needs.pipeline-init.outputs.environment }}
      change_type: ${{ needs.pipeline-init.outputs.is_production == 'true' && 'normal' || 'standard' }}
      security_scan_status: ${{ needs.security-scans.outputs.overall_status || 'UNKNOWN' }}
      security_findings: ${{ needs.security-scans.outputs.total_findings || '0' }}

  # ============================================================================
  # STAGE 5: Deployment (Environment-Specific)
  # ============================================================================

  deploy-to-environment:
    name: "üöÄ Deploy Application"
    needs: [pipeline-init, create-change-request]
    if: |
      always() &&
      needs.pipeline-init.outputs.should_deploy == 'true' &&
      !inputs.skip_deploy &&
      (needs.create-change-request.result == 'success' || needs.create-change-request.result == 'skipped')
    uses: ./.github/workflows/deploy-environment.yaml
    secrets: inherit
    with:
      environment: ${{ needs.pipeline-init.outputs.environment }}
      change_request_sys_id: ${{ needs.create-change-request.outputs.change_request_sys_id || '' }}
      wait_for_ready: true
      timeout_minutes: ${{ needs.pipeline-init.outputs.is_production == 'true' && 15 || 10 }}

  # ============================================================================
  # STAGE 6: Post-Deployment Validation
  # ============================================================================

  smoke-tests:
    name: "‚úÖ Smoke Tests"
    needs: [pipeline-init, deploy-to-environment]
    if: needs.deploy-to-environment.result == 'success'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig --name ${{ env.CLUSTER_NAME }} --region ${{ env.AWS_REGION }}

      - name: Wait for All Pods Ready
        run: |
          NAMESPACE="microservices-${{ needs.pipeline-init.outputs.environment }}"
          echo "‚è≥ Waiting for all pods to be ready in $NAMESPACE..."

          kubectl wait --for=condition=ready pods --all \
            -n $NAMESPACE \
            --timeout=300s || echo "‚ö†Ô∏è Some pods not ready within timeout"

      - name: Test Frontend Endpoint
        id: test-frontend
        run: |
          # Get frontend URL from Istio ingress
          FRONTEND_URL=$(kubectl get svc -n istio-system istio-ingressgateway \
            -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")

          if [ -z "$FRONTEND_URL" ]; then
            echo "‚ö†Ô∏è Frontend URL not yet available (LoadBalancer provisioning)"
            echo "status=pending" >> $GITHUB_OUTPUT
          else
            echo "Testing frontend at: http://$FRONTEND_URL/"
            if curl -f -s -o /dev/null -w "%{http_code}" "http://$FRONTEND_URL/" | grep -q "200"; then
              echo "‚úÖ Frontend is accessible"
              echo "status=success" >> $GITHUB_OUTPUT
              echo "url=http://$FRONTEND_URL" >> $GITHUB_OUTPUT
            else
              echo "‚ùå Frontend returned non-200 status"
              echo "status=failure" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Smoke Test Summary
        run: |
          echo "## ‚úÖ Smoke Tests Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Test | Result |" >> $GITHUB_STEP_SUMMARY
          echo "|------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Pod Readiness | ‚úÖ Complete |" >> $GITHUB_STEP_SUMMARY
          echo "| Frontend Endpoint | ${{ steps.test-frontend.outputs.status }} |" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.test-frontend.outputs.status }}" == "success" ]; then
            echo "| URL | ${{ steps.test-frontend.outputs.url }} |" >> $GITHUB_STEP_SUMMARY
          fi

  # ============================================================================
  # STAGE 7: Update ServiceNow & Notifications
  # ============================================================================

  update-change-request:
    name: "‚úÖ Update ServiceNow"
    needs: [create-change-request, deploy-to-environment, smoke-tests]
    if: |
      always() &&
      needs.create-change-request.outputs.change_request_sys_id != ''
    runs-on: ubuntu-latest

    steps:
      - name: Determine Final Status
        id: status
        run: |
          DEPLOY_STATUS="${{ needs.deploy-to-environment.result }}"
          SMOKE_STATUS="${{ needs.smoke-tests.result }}"

          if [ "$DEPLOY_STATUS" == "success" ] && [ "$SMOKE_STATUS" == "success" ]; then
            echo "final_status=successful" >> $GITHUB_OUTPUT
            echo "state=3" >> $GITHUB_OUTPUT  # Closed
            echo "notes=Deployment completed successfully. All smoke tests passed." >> $GITHUB_OUTPUT
          else
            echo "final_status=unsuccessful" >> $GITHUB_OUTPUT
            echo "state=4" >> $GITHUB_OUTPUT  # Closed Incomplete
            echo "notes=Deployment failed or smoke tests did not pass. Check workflow logs." >> $GITHUB_OUTPUT
          fi

      - name: Update Change Request via REST API
        run: |
          CHANGE_SYS_ID="${{ needs.create-change-request.outputs.change_request_sys_id }}"
          CHANGE_NUMBER="${{ needs.create-change-request.outputs.change_request_number }}"

          echo "## üîÑ Updating Change Request $CHANGE_NUMBER" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Prepare update payload
          UPDATE_PAYLOAD='{"close_code":"CLOSE_CODE_PLACEHOLDER","close_notes":"CLOSE_NOTES_PLACEHOLDER","state":"STATE_PLACEHOLDER"}'

          # Replace placeholders
          UPDATE_PAYLOAD=$(echo "$UPDATE_PAYLOAD" | sed "s|CLOSE_CODE_PLACEHOLDER|${{ steps.status.outputs.final_status }}|g")
          UPDATE_PAYLOAD=$(echo "$UPDATE_PAYLOAD" | sed "s|CLOSE_NOTES_PLACEHOLDER|${{ steps.status.outputs.notes }}\\n\\nWorkflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\\nCommit: ${{ github.sha }}|g")
          UPDATE_PAYLOAD=$(echo "$UPDATE_PAYLOAD" | sed "s|STATE_PLACEHOLDER|${{ steps.status.outputs.state }}|g")

          echo "Updating change request in ServiceNow..."

          # Update change request using REST API
          RESPONSE=$(curl -s -w "\n%{http_code}" -X PATCH \
            -H "Content-Type: application/json" \
            -H "Accept: application/json" \
            -u "${{ secrets.SERVICENOW_USERNAME }}:${{ secrets.SERVICENOW_PASSWORD }}" \
            -d "$UPDATE_PAYLOAD" \
            "https://calitiiltddemo3.service-now.com/api/now/table/change_request/${CHANGE_SYS_ID}")

          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | sed '$d')

          echo "HTTP Status: $HTTP_CODE"

          if [ "$HTTP_CODE" == "200" ]; then
            echo "‚úÖ Change request updated successfully" >> $GITHUB_STEP_SUMMARY
            echo "Status: ${{ steps.status.outputs.final_status }}" >> $GITHUB_STEP_SUMMARY
            echo "State: ${{ steps.status.outputs.state }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ö†Ô∏è Failed to update change request (HTTP $HTTP_CODE)" >> $GITHUB_STEP_SUMMARY
            echo "Response: $BODY" >> $GITHUB_STEP_SUMMARY
            # Don't fail the workflow - change was already created and deployed
          fi

  # ============================================================================
  # STAGE 8: Pipeline Summary
  # ============================================================================

  pipeline-summary:
    name: "üìä Pipeline Summary"
    needs:
      - pipeline-init
      - security-scans
      - detect-terraform-changes
      - detect-service-changes
      - build-and-push
      - deploy-to-environment
      - smoke-tests
    if: always()
    runs-on: ubuntu-latest

    steps:
      - name: Generate Summary
        run: |
          echo "# üöÄ Master CI/CD Pipeline Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Pipeline Configuration" >> $GITHUB_STEP_SUMMARY
          echo "| Parameter | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | **${{ needs.pipeline-init.outputs.environment }}** |" >> $GITHUB_STEP_SUMMARY
          echo "| Trigger | ${{ github.event_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Branch | \`${{ github.ref_name }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Actor | @${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "## Stage Results" >> $GITHUB_STEP_SUMMARY
          echo "| Stage | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Security Scans | ${{ needs.security-scans.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Terraform Changes | ${{ needs.detect-terraform-changes.outputs.terraform_changed == 'true' && '‚úÖ Detected' || '‚è≠Ô∏è None' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Service Changes | ${{ needs.detect-service-changes.outputs.has_changes == 'true' && '‚úÖ Detected' || '‚è≠Ô∏è None' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Build Images | ${{ needs.build-and-push.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deploy | ${{ needs.deploy-to-environment.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Smoke Tests | ${{ needs.smoke-tests.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "## üéØ Final Result" >> $GITHUB_STEP_SUMMARY
          if [ "${{ needs.deploy-to-environment.result }}" == "success" ] && [ "${{ needs.smoke-tests.result }}" == "success" ]; then
            echo "### ‚úÖ **DEPLOYMENT SUCCESSFUL**" >> $GITHUB_STEP_SUMMARY
            echo "Application successfully deployed to **${{ needs.pipeline-init.outputs.environment }}**" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.deploy-to-environment.result }}" == "skipped" ]; then
            echo "### ‚ÑπÔ∏è **BUILD ONLY**" >> $GITHUB_STEP_SUMMARY
            echo "No deployment occurred (PR or manual skip)" >> $GITHUB_STEP_SUMMARY
          else
            echo "### ‚ùå **DEPLOYMENT FAILED**" >> $GITHUB_STEP_SUMMARY
            echo "Check individual stage logs for details" >> $GITHUB_STEP_SUMMARY
          fi

  # ============================================================================
  # STAGE 8: Infrastructure Discovery & Evidence Collection
  # ============================================================================

  collect-evidence:
    name: "üìã Collect Evidence"
    needs: [pipeline-init, deploy-to-environment, smoke-tests, create-change-request]
    # Run if deployment succeeded, to collect evidence of what's running
    if: |
      always() &&
      needs.pipeline-init.outputs.environment != '' &&
      needs.deploy-to-environment.result == 'success'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: eu-west-2

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig --region eu-west-2 --name microservices

      - name: Collect EKS Cluster Evidence
        id: eks-evidence
        run: |
          echo "## üîç EKS Cluster Evidence" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ needs.pipeline-init.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Cluster:** microservices" >> $GITHUB_STEP_SUMMARY
          echo "**Region:** eu-west-2" >> $GITHUB_STEP_SUMMARY
          echo "**Collection Time:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Get cluster info
          CLUSTER_VERSION=$(aws eks describe-cluster --name microservices --region eu-west-2 --query 'cluster.version' --output text)
          CLUSTER_STATUS=$(aws eks describe-cluster --name microservices --region eu-west-2 --query 'cluster.status' --output text)

          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Cluster Version | $CLUSTER_VERSION |" >> $GITHUB_STEP_SUMMARY
          echo "| Cluster Status | $CLUSTER_STATUS |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Get node info
          echo "### Node Status" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          kubectl get nodes -o wide >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Get deployments in target namespace
          NAMESPACE="microservices-${{ needs.pipeline-init.outputs.environment }}"
          echo "### Deployments in $NAMESPACE" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          kubectl get deployments -n $NAMESPACE -o wide >> $GITHUB_STEP_SUMMARY 2>&1 || echo "Namespace $NAMESPACE not found" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Get pods in target namespace
          echo "### Pods in $NAMESPACE" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          kubectl get pods -n $NAMESPACE -o wide >> $GITHUB_STEP_SUMMARY 2>&1 || echo "Namespace $NAMESPACE not found" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Store evidence for ServiceNow
          echo "cluster_version=$CLUSTER_VERSION" >> $GITHUB_OUTPUT
          echo "cluster_status=$CLUSTER_STATUS" >> $GITHUB_OUTPUT

          DEPLOYMENT_COUNT=$(kubectl get deployments -n $NAMESPACE --no-headers 2>/dev/null | wc -l || echo "0")
          POD_COUNT=$(kubectl get pods -n $NAMESPACE --no-headers 2>/dev/null | wc -l || echo "0")
          RUNNING_PODS=$(kubectl get pods -n $NAMESPACE --field-selector=status.phase=Running --no-headers 2>/dev/null | wc -l || echo "0")

          echo "deployment_count=$DEPLOYMENT_COUNT" >> $GITHUB_OUTPUT
          echo "pod_count=$POD_COUNT" >> $GITHUB_OUTPUT
          echo "running_pods=$RUNNING_PODS" >> $GITHUB_OUTPUT

      - name: Collect Terraform State Evidence
        id: terraform-evidence
        run: |
          echo "## üèóÔ∏è Terraform Infrastructure Evidence" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          cd terraform-aws

          # Count resources by type
          echo "### Resource Summary" >> $GITHUB_STEP_SUMMARY
          echo "| Resource Type | Count |" >> $GITHUB_STEP_SUMMARY
          echo "|---------------|-------|" >> $GITHUB_STEP_SUMMARY

          VPC_COUNT=$(terraform state list 2>/dev/null | grep -c "aws_vpc" || echo "0")
          SUBNET_COUNT=$(terraform state list 2>/dev/null | grep -c "aws_subnet" || echo "0")
          EKS_COUNT=$(terraform state list 2>/dev/null | grep -c "aws_eks_cluster" || echo "0")
          NODE_GROUP_COUNT=$(terraform state list 2>/dev/null | grep -c "aws_eks_node_group" || echo "0")
          ECR_COUNT=$(terraform state list 2>/dev/null | grep -c "aws_ecr_repository" || echo "0")
          REDIS_COUNT=$(terraform state list 2>/dev/null | grep -c "aws_elasticache_cluster" || echo "0")

          echo "| VPC | $VPC_COUNT |" >> $GITHUB_STEP_SUMMARY
          echo "| Subnets | $SUBNET_COUNT |" >> $GITHUB_STEP_SUMMARY
          echo "| EKS Clusters | $EKS_COUNT |" >> $GITHUB_STEP_SUMMARY
          echo "| Node Groups | $NODE_GROUP_COUNT |" >> $GITHUB_STEP_SUMMARY
          echo "| ECR Repositories | $ECR_COUNT |" >> $GITHUB_STEP_SUMMARY
          echo "| Redis Clusters | $REDIS_COUNT |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Store for ServiceNow
          TOTAL_RESOURCES=$(terraform state list 2>/dev/null | wc -l || echo "0")
          echo "total_resources=$TOTAL_RESOURCES" >> $GITHUB_OUTPUT

      - name: Send Evidence to ServiceNow (via REST API)
        if: needs.create-change-request.outputs.change_request_sys_id != ''
        env:
          CHANGE_SYS_ID: ${{ needs.create-change-request.outputs.change_request_sys_id }}
        run: |
          echo "## üì§ Sending Evidence to ServiceNow" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Prepare evidence payload
          # yamllint disable-line rule:line-length
          EVIDENCE='{"work_notes":"Deployment Evidence Collection\n\n=== EKS Cluster Evidence ===\nCluster Version: CLUSTER_VERSION_PLACEHOLDER\nCluster Status: CLUSTER_STATUS_PLACEHOLDER\nDeployments: DEPLOYMENT_COUNT_PLACEHOLDER\nTotal Pods: POD_COUNT_PLACEHOLDER\nRunning Pods: RUNNING_PODS_PLACEHOLDER\n\n=== Infrastructure Evidence ===\nTotal Terraform Resources: TOTAL_RESOURCES_PLACEHOLDER\n\n=== Workflow Details ===\nRun: WORKFLOW_URL_PLACEHOLDER\nCommit: COMMIT_SHA_PLACEHOLDER\nActor: ACTOR_PLACEHOLDER\nTimestamp: TIMESTAMP_PLACEHOLDER"}'

          # Replace placeholders with actual values
          EVIDENCE=$(echo "$EVIDENCE" | sed "s|CLUSTER_VERSION_PLACEHOLDER|${{ steps.eks-evidence.outputs.cluster_version }}|g")
          EVIDENCE=$(echo "$EVIDENCE" | sed "s|CLUSTER_STATUS_PLACEHOLDER|${{ steps.eks-evidence.outputs.cluster_status }}|g")
          EVIDENCE=$(echo "$EVIDENCE" | sed "s|DEPLOYMENT_COUNT_PLACEHOLDER|${{ steps.eks-evidence.outputs.deployment_count }}|g")
          EVIDENCE=$(echo "$EVIDENCE" | sed "s|POD_COUNT_PLACEHOLDER|${{ steps.eks-evidence.outputs.pod_count }}|g")
          EVIDENCE=$(echo "$EVIDENCE" | sed "s|RUNNING_PODS_PLACEHOLDER|${{ steps.eks-evidence.outputs.running_pods }}|g")
          EVIDENCE=$(echo "$EVIDENCE" | sed "s|TOTAL_RESOURCES_PLACEHOLDER|${{ steps.terraform-evidence.outputs.total_resources }}|g")
          EVIDENCE=$(echo "$EVIDENCE" | sed "s|WORKFLOW_URL_PLACEHOLDER|${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|g")
          EVIDENCE=$(echo "$EVIDENCE" | sed "s|COMMIT_SHA_PLACEHOLDER|${{ github.sha }}|g")
          EVIDENCE=$(echo "$EVIDENCE" | sed "s|ACTOR_PLACEHOLDER|${{ github.actor }}|g")
          EVIDENCE=$(echo "$EVIDENCE" | sed "s|TIMESTAMP_PLACEHOLDER|$(date -u '+%Y-%m-%d %H:%M:%S UTC')|g")

          # Update change request with evidence using REST API
          RESPONSE=$(curl -s -w "\n%{http_code}" -X PATCH \
            -H "Content-Type: application/json" \
            -H "Accept: application/json" \
            -u "${{ secrets.SERVICENOW_USERNAME }}:${{ secrets.SERVICENOW_PASSWORD }}" \
            -d "$EVIDENCE" \
            "https://calitiiltddemo3.service-now.com/api/now/table/change_request/${CHANGE_SYS_ID}")

          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | sed '$d')

          if [ "$HTTP_CODE" == "200" ]; then
            echo "‚úÖ Evidence sent to ServiceNow successfully" >> $GITHUB_STEP_SUMMARY
            echo "Change Request: CHG${CHANGE_SYS_ID}" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ö†Ô∏è Failed to send evidence to ServiceNow (HTTP $HTTP_CODE)" >> $GITHUB_STEP_SUMMARY
            echo "Response: $BODY" >> $GITHUB_STEP_SUMMARY
          fi
