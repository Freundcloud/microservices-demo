---
name: EKS Cluster Discovery to ServiceNow

"on":
  schedule:
    - cron: '0 */6 * * *'  # Every 6 hours
  workflow_dispatch:  # Manual trigger
  push:
    paths:
      - 'kustomize/overlays/**'
      - 'kubernetes-manifests/**'
      - '.github/workflows/deploy-with-servicenow.yaml'

env:
  AWS_REGION: eu-west-2
  CLUSTER_NAME: microservices
  SERVICENOW_INSTANCE_URL: ${{ secrets.SERVICENOW_INSTANCE_URL }}
  SERVICENOW_USERNAME: ${{ secrets.SERVICENOW_USERNAME }}
  SERVICENOW_PASSWORD: ${{ secrets.SERVICENOW_PASSWORD }}

jobs:
  discover-eks-cluster:
    name: Discover EKS Cluster
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq curl

      - name: Discover EKS cluster information
        id: cluster-info
        run: |
          echo "## EKS Cluster Discovery" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Cluster**: ${{ env.CLUSTER_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "**Region**: ${{ env.AWS_REGION }}" >> $GITHUB_STEP_SUMMARY
          echo "**Discovery Time**: $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Get cluster details
          aws eks describe-cluster --name ${{ env.CLUSTER_NAME }} --region ${{ env.AWS_REGION }} > cluster.json

          # Extract key information
          CLUSTER_ARN=$(jq -r '.cluster.arn' cluster.json)
          CLUSTER_VERSION=$(jq -r '.cluster.version' cluster.json)
          CLUSTER_ENDPOINT=$(jq -r '.cluster.endpoint' cluster.json)
          CLUSTER_STATUS=$(jq -r '.cluster.status' cluster.json)
          VPC_ID=$(jq -r '.cluster.resourcesVpcConfig.vpcId' cluster.json)
          CREATED_AT=$(jq -r '.cluster.createdAt' cluster.json)

          echo "cluster_arn=$CLUSTER_ARN" >> $GITHUB_OUTPUT
          echo "cluster_version=$CLUSTER_VERSION" >> $GITHUB_OUTPUT
          echo "cluster_endpoint=$CLUSTER_ENDPOINT" >> $GITHUB_OUTPUT
          echo "cluster_status=$CLUSTER_STATUS" >> $GITHUB_OUTPUT
          echo "vpc_id=$VPC_ID" >> $GITHUB_OUTPUT

          echo "### Cluster Details" >> $GITHUB_STEP_SUMMARY
          echo "- **ARN**: \`$CLUSTER_ARN\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: Kubernetes $CLUSTER_VERSION" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: $CLUSTER_STATUS" >> $GITHUB_STEP_SUMMARY
          echo "- **VPC**: $VPC_ID" >> $GITHUB_STEP_SUMMARY
          echo "- **Created**: $CREATED_AT" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Get node groups
          echo "### Node Groups" >> $GITHUB_STEP_SUMMARY
          aws eks list-nodegroups --cluster-name ${{ env.CLUSTER_NAME }} --region ${{ env.AWS_REGION }} > nodegroups.json
          jq -r '.nodegroups[]' nodegroups.json | while read -r ng; do
            NG_INFO=$(aws eks describe-nodegroup --cluster-name ${{ env.CLUSTER_NAME }} --nodegroup-name "$ng" --region ${{ env.AWS_REGION }})
            INSTANCE_TYPE=$(echo $NG_INFO | jq -r '.nodegroup.instanceTypes[0]')
            DESIRED=$(echo $NG_INFO | jq -r '.nodegroup.scalingConfig.desiredSize')
            echo "- **$ng**: $INSTANCE_TYPE (Desired: $DESIRED)" >> $GITHUB_STEP_SUMMARY
          done
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig --name ${{ env.CLUSTER_NAME }} --region ${{ env.AWS_REGION }}

      - name: Discover EKS nodes
        id: discover-nodes
        run: |
          echo "### EKS Nodes Discovery" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Get all node groups
          NODE_GROUPS=$(aws eks list-nodegroups --cluster-name ${{ env.CLUSTER_NAME }} --region ${{ env.AWS_REGION }} | jq -r '.nodegroups[]')

          # Create JSON array for all nodes
          echo '{"nodes": []}' > all-nodes.json

          for NG in $NODE_GROUPS; do
            echo "#### Node Group: $NG" >> $GITHUB_STEP_SUMMARY

            # Get node group details
            NG_INFO=$(aws eks describe-nodegroup --cluster-name ${{ env.CLUSTER_NAME }} --nodegroup-name "$NG" --region ${{ env.AWS_REGION }})

            # Extract node group metadata
            INSTANCE_TYPES=$(echo "$NG_INFO" | jq -r '.nodegroup.instanceTypes[]')
            AMI_TYPE=$(echo "$NG_INFO" | jq -r '.nodegroup.amiType')
            DISK_SIZE=$(echo "$NG_INFO" | jq -r '.nodegroup.diskSize')
            SCALING_MIN=$(echo "$NG_INFO" | jq -r '.nodegroup.scalingConfig.minSize')
            SCALING_MAX=$(echo "$NG_INFO" | jq -r '.nodegroup.scalingConfig.maxSize')
            SCALING_DESIRED=$(echo "$NG_INFO" | jq -r '.nodegroup.scalingConfig.desiredSize')
            NG_STATUS=$(echo "$NG_INFO" | jq -r '.nodegroup.status')
            NG_ARN=$(echo "$NG_INFO" | jq -r '.nodegroup.nodegroupArn')
            CREATED_AT=$(echo "$NG_INFO" | jq -r '.nodegroup.createdAt')

            # Get EC2 instances in this node group via ASG
            ASG_NAME=$(echo "$NG_INFO" | jq -r '.nodegroup.resources.autoScalingGroups[0].name')

            if [ -n "$ASG_NAME" ] && [ "$ASG_NAME" != "null" ]; then
              # Get instances from ASG
              INSTANCE_IDS=$(aws autoscaling describe-auto-scaling-groups --auto-scaling-group-names "$ASG_NAME" --region ${{ env.AWS_REGION }} | \
                jq -r '.AutoScalingGroups[0].Instances[].InstanceId')

              NODE_COUNT=0
              for INSTANCE_ID in $INSTANCE_IDS; do
                # Get EC2 instance details
                INSTANCE_INFO=$(aws ec2 describe-instances --instance-ids "$INSTANCE_ID" --region ${{ env.AWS_REGION }} | jq -r '.Reservations[0].Instances[0]')

                INSTANCE_TYPE=$(echo "$INSTANCE_INFO" | jq -r '.InstanceType')
                PRIVATE_IP=$(echo "$INSTANCE_INFO" | jq -r '.PrivateIpAddress')
                PUBLIC_IP=$(echo "$INSTANCE_INFO" | jq -r '.PublicIpAddress // "N/A"')
                AZ=$(echo "$INSTANCE_INFO" | jq -r '.Placement.AvailabilityZone')
                STATE=$(echo "$INSTANCE_INFO" | jq -r '.State.Name')
                LAUNCH_TIME=$(echo "$INSTANCE_INFO" | jq -r '.LaunchTime')

                # Get Kubernetes node name from kubectl
                K8S_NODE_NAME=$(kubectl get nodes -o json | jq -r --arg instance_id "$INSTANCE_ID" \
                  '.items[] | select(.spec.providerID | contains($instance_id)) | .metadata.name')

                # Get node resources if node exists in Kubernetes
                if [ -n "$K8S_NODE_NAME" ] && [ "$K8S_NODE_NAME" != "null" ]; then
                  K8S_NODE_INFO=$(kubectl get node "$K8S_NODE_NAME" -o json)
                  K8S_VERSION=$(echo "$K8S_NODE_INFO" | jq -r '.status.nodeInfo.kubeletVersion')
                  CAPACITY_CPU=$(echo "$K8S_NODE_INFO" | jq -r '.status.capacity.cpu')
                  CAPACITY_MEMORY=$(echo "$K8S_NODE_INFO" | jq -r '.status.capacity.memory')
                  ALLOCATABLE_CPU=$(echo "$K8S_NODE_INFO" | jq -r '.status.allocatable.cpu')
                  ALLOCATABLE_MEMORY=$(echo "$K8S_NODE_INFO" | jq -r '.status.allocatable.memory')
                  K8S_STATUS=$(echo "$K8S_NODE_INFO" | jq -r '.status.conditions[] | select(.type=="Ready") | .status')
                else
                  K8S_VERSION=""
                  CAPACITY_CPU=""
                  CAPACITY_MEMORY=""
                  ALLOCATABLE_CPU=""
                  ALLOCATABLE_MEMORY=""
                  K8S_STATUS="Unknown"
                fi

                # Create node JSON
                NODE_JSON=$(jq -n \
                  --arg ng "$NG" \
                  --arg instance_id "$INSTANCE_ID" \
                  --arg instance_type "$INSTANCE_TYPE" \
                  --arg private_ip "$PRIVATE_IP" \
                  --arg public_ip "$PUBLIC_IP" \
                  --arg az "$AZ" \
                  --arg state "$STATE" \
                  --arg launch_time "$LAUNCH_TIME" \
                  --arg k8s_name "$K8S_NODE_NAME" \
                  --arg k8s_version "$K8S_VERSION" \
                  --arg k8s_status "$K8S_STATUS" \
                  --arg capacity_cpu "$CAPACITY_CPU" \
                  --arg capacity_memory "$CAPACITY_MEMORY" \
                  --arg allocatable_cpu "$ALLOCATABLE_CPU" \
                  --arg allocatable_memory "$ALLOCATABLE_MEMORY" \
                  --arg ng_arn "$NG_ARN" \
                  --arg ami_type "$AMI_TYPE" \
                  --arg disk_size "$DISK_SIZE" \
                  '{
                    nodegroup: $ng,
                    instance_id: $instance_id,
                    instance_type: $instance_type,
                    private_ip: $private_ip,
                    public_ip: $public_ip,
                    availability_zone: $az,
                    state: $state,
                    launch_time: $launch_time,
                    kubernetes_name: $k8s_name,
                    kubernetes_version: $k8s_version,
                    kubernetes_status: $k8s_status,
                    capacity_cpu: $capacity_cpu,
                    capacity_memory: $capacity_memory,
                    allocatable_cpu: $allocatable_cpu,
                    allocatable_memory: $allocatable_memory,
                    nodegroup_arn: $ng_arn,
                    ami_type: $ami_type,
                    disk_size: $disk_size
                  }')

                # Append to all nodes
                jq --argjson node "$NODE_JSON" '.nodes += [$node]' all-nodes.json > tmp-nodes.json
                mv tmp-nodes.json all-nodes.json

                echo "  - **$K8S_NODE_NAME** ($INSTANCE_TYPE) - $PRIVATE_IP - $STATE" >> $GITHUB_STEP_SUMMARY
                NODE_COUNT=$((NODE_COUNT + 1))
              done

              echo "  - **Total nodes**: $NODE_COUNT" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            fi
          done

          TOTAL_NODES=$(jq '.nodes | length' all-nodes.json)
          echo "**Total EKS nodes discovered**: $TOTAL_NODES" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: Discover microservices in all environments
        id: discover-services
        run: |
          echo "### Microservices Discovery" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          NAMESPACES=("microservices-dev" "microservices-qa" "microservices-prod")

          # Create JSON array for all services
          echo '{"services": []}' > all-services.json

          for NAMESPACE in "${NAMESPACES[@]}"; do
            if kubectl get namespace $NAMESPACE &> /dev/null; then
              echo "#### Environment: ${NAMESPACE##*-}" >> $GITHUB_STEP_SUMMARY

              # Get all deployments with language detection
              kubectl get deployments -n $NAMESPACE -o json | \
                jq --arg ns "$NAMESPACE" --arg env "${NAMESPACE##*-}" '
                  .items[] |
                  # Detect language from labels or common patterns
                  (.metadata.labels.language //
                   (.metadata.labels.app // .metadata.name) as $svc |
                   if $svc | test("frontend|productcatalogservice|shippingservice|checkoutservice") then "Go"
                   elif $svc | test("emailservice|recommendationservice") then "Python"
                   elif $svc | test("adservice|shoppingassistant") then "Java"
                   elif $svc | test("currencyservice|paymentservice") then "Node.js"
                   elif $svc | test("cartservice") then "C#"
                   elif $svc | test("redis") then "Redis"
                   else ""
                   end
                  ) as $language |
                  {
                    name: .metadata.name,
                    namespace: $ns,
                    environment: $env,
                    replicas: .spec.replicas,
                    ready_replicas: (.status.readyReplicas // 0),
                    image: .spec.template.spec.containers[0].image,
                    image_tag: (.spec.template.spec.containers[0].image | split(":")[1]),
                    created: .metadata.creationTimestamp,
                    labels: .metadata.labels,
                    status: (if .status.readyReplicas == .spec.replicas then "Running" else "Degraded" end),
                    language: $language
                  }
                ' > services-$NAMESPACE.json

              # Display services
              jq -r '.name as $name | .ready_replicas as $ready | .replicas as $total | .status as $status |
                     "- **\($name)**: \($ready)/\($total) replicas - \($status)"' services-$NAMESPACE.json >> $GITHUB_STEP_SUMMARY || true

              # Append to all services
              jq --slurpfile new services-$NAMESPACE.json '.services += $new' all-services.json > tmp.json
              mv tmp.json all-services.json

              echo "" >> $GITHUB_STEP_SUMMARY
            else
              echo "⚠️ Namespace $NAMESPACE not found" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            fi
          done

          TOTAL_SERVICES=$(jq '.services | length' all-services.json)
          echo "**Total services discovered**: $TOTAL_SERVICES" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: Upload cluster info to ServiceNow CMDB
        if: ${{ env.SERVICENOW_PASSWORD != '' }}
        env:
          CLUSTER_ARN: ${{ steps.cluster-info.outputs.cluster_arn }}
          CLUSTER_VERSION: ${{ steps.cluster-info.outputs.cluster_version }}
          CLUSTER_ENDPOINT: ${{ steps.cluster-info.outputs.cluster_endpoint }}
          CLUSTER_STATUS: ${{ steps.cluster-info.outputs.cluster_status }}
          VPC_ID: ${{ steps.cluster-info.outputs.vpc_id }}
        run: |
          echo "### ServiceNow CMDB Update" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Create Basic Auth header
          BASIC_AUTH=$(echo -n "${{ secrets.SERVICENOW_USERNAME }}:${{ secrets.SERVICENOW_PASSWORD }}" | base64)

          # Prepare cluster payload using jq with all values from environment variables
          TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)

          # Extract IP address from endpoint URL (remove https:// and take the hostname part)
          IP_ADDRESS=$(echo "${CLUSTER_ENDPOINT}" | sed 's|https://||' | cut -d'.' -f1 | sed 's|^||')

          # Get the full hostname for ip_address field
          ENDPOINT_HOST=$(echo "${CLUSTER_ENDPOINT}" | sed 's|https://||' | cut -d':' -f1)

          # Create payload using jq with --arg to safely handle all values
          # NOTE: u_eks_cluster table has u_u_ prefix fields due to ServiceNow CMDB inheritance
          CLUSTER_PAYLOAD=$(jq -n \
            --arg name "${CLUSTER_NAME}" \
            --arg arn "${CLUSTER_ARN}" \
            --arg version "Kubernetes ${CLUSTER_VERSION}" \
            --arg endpoint "${CLUSTER_ENDPOINT}" \
            --arg status "${CLUSTER_STATUS}" \
            --arg region "${AWS_REGION}" \
            --arg vpc "${VPC_ID}" \
            --arg timestamp "${TIMESTAMP}" \
            --arg ip_addr "${ENDPOINT_HOST}" \
            '{
              name: $name,
              ip_address: $ip_addr,
              u_u_cluster_name: $name,
              u_u_arn: $arn,
              u_u_version: $version,
              u_u_endpoint: $endpoint,
              u_u_status: $status,
              u_u_region: $region,
              u_u_vpc_id: $vpc,
              u_u_provider: "AWS EKS",
              u_u_last_discovered: $timestamp,
              u_u_discovered_by: "GitHub Actions"
            }')

          # Check if cluster exists in CMDB (query by name field, not u_u_cluster_name)
          EXISTING_CLUSTER=$(curl -s -X GET \
            "${SERVICENOW_INSTANCE_URL}/api/now/table/u_eks_cluster?sysparm_query=name=${CLUSTER_NAME}&sysparm_limit=1" \
            -H "Authorization: Basic ${BASIC_AUTH}" \
            -H "Content-Type: application/json" 2>/dev/null || echo '{"result":[]}')

          CLUSTER_SYS_ID=$(echo "$EXISTING_CLUSTER" | jq -r '.result[0].sys_id // empty')

          if [ -n "$CLUSTER_SYS_ID" ]; then
            echo "Updating existing cluster record: $CLUSTER_SYS_ID"
            RESPONSE=$(curl -s -X PUT \
              "${SERVICENOW_INSTANCE_URL}/api/now/table/u_eks_cluster/$CLUSTER_SYS_ID" \
              -H "Authorization: Basic ${BASIC_AUTH}" \
              -H "Content-Type: application/json" \
              -d "$CLUSTER_PAYLOAD" 2>/dev/null || echo '{}')

            echo "✅ Updated existing cluster CI in ServiceNow" >> $GITHUB_STEP_SUMMARY
          else
            echo "Creating new cluster record"
            CLUSTER_RESPONSE=$(curl -s -X POST \
              "${SERVICENOW_INSTANCE_URL}/api/now/table/u_eks_cluster" \
              -H "Authorization: Basic ${BASIC_AUTH}" \
              -H "Content-Type: application/json" \
              -d "$CLUSTER_PAYLOAD" 2>/dev/null || echo '{"result":{"sys_id":""}}')

            CLUSTER_SYS_ID=$(echo "$CLUSTER_RESPONSE" | jq -r '.result.sys_id // empty')
            echo "✅ Created new cluster CI in ServiceNow" >> $GITHUB_STEP_SUMMARY
          fi

          if [ -n "$CLUSTER_SYS_ID" ]; then
            echo "CLUSTER_SYS_ID=$CLUSTER_SYS_ID" >> $GITHUB_ENV
            echo "- **Cluster CI sys_id**: \`$CLUSTER_SYS_ID\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "⚠️ Failed to create/update cluster CI" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Upload EKS nodes to ServiceNow CMDB
        if: ${{ env.SERVICENOW_PASSWORD != '' }}
        run: |
          # Check if CLUSTER_SYS_ID was set by previous step
          if [ -z "${CLUSTER_SYS_ID}" ]; then
            echo "⚠️ CLUSTER_SYS_ID not set, skipping nodes upload" >> $GITHUB_STEP_SUMMARY
            exit 0
          fi

          # Create Basic Auth header
          BASIC_AUTH=$(echo -n "${{ secrets.SERVICENOW_USERNAME }}:${{ secrets.SERVICENOW_PASSWORD }}" | base64)

          echo "Uploading EKS nodes to ServiceNow CMDB..."

          # Read all nodes
          NODES=$(jq -c '.nodes[]' all-nodes.json)
          NODE_COUNT=0

          while IFS= read -r node; do
            INSTANCE_ID=$(echo "$node" | jq -r '.instance_id')
            K8S_NAME=$(echo "$node" | jq -r '.kubernetes_name')
            INSTANCE_TYPE=$(echo "$node" | jq -r '.instance_type')
            PRIVATE_IP=$(echo "$node" | jq -r '.private_ip')
            PUBLIC_IP=$(echo "$node" | jq -r '.public_ip')
            AZ=$(echo "$node" | jq -r '.availability_zone')
            STATE=$(echo "$node" | jq -r '.state')
            K8S_VERSION=$(echo "$node" | jq -r '.kubernetes_version')
            K8S_STATUS=$(echo "$node" | jq -r '.kubernetes_status')
            CAPACITY_CPU=$(echo "$node" | jq -r '.capacity_cpu')
            CAPACITY_MEMORY=$(echo "$node" | jq -r '.capacity_memory')
            ALLOCATABLE_CPU=$(echo "$node" | jq -r '.allocatable_cpu')
            ALLOCATABLE_MEMORY=$(echo "$node" | jq -r '.allocatable_memory')
            NODEGROUP=$(echo "$node" | jq -r '.nodegroup')
            AMI_TYPE=$(echo "$node" | jq -r '.ami_type')
            DISK_SIZE=$(echo "$node" | jq -r '.disk_size')

            # Prepare node payload for cmdb_ci_server table
            TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)

            # Use Kubernetes node name as primary name, fallback to instance ID
            NODE_NAME="${K8S_NAME:-$INSTANCE_ID}"

            # Parse CPU count and memory from Kubernetes format
            # CPU: usually a number like "4" or "8"
            # Memory: format like "16237988Ki" - convert to MB
            CPU_COUNT="${CAPACITY_CPU:-0}"
            MEMORY_KB=$(echo "$CAPACITY_MEMORY" | sed 's/Ki$//')
            MEMORY_MB=$((MEMORY_KB / 1024))
            DISK_SIZE_GB="${DISK_SIZE:-0}"

            NODE_PAYLOAD=$(jq -n \
              --arg name "$NODE_NAME" \
              --arg ip "$PRIVATE_IP" \
              --arg instance_id "$INSTANCE_ID" \
              --arg instance_type "$INSTANCE_TYPE" \
              --arg az "$AZ" \
              --arg state "$STATE" \
              --arg k8s_version "$K8S_VERSION" \
              --arg k8s_status "$K8S_STATUS" \
              --arg cpu_count "$CPU_COUNT" \
              --arg memory_mb "$MEMORY_MB" \
              --arg alloc_cpu "$ALLOCATABLE_CPU" \
              --arg alloc_memory "$ALLOCATABLE_MEMORY" \
              --arg nodegroup "$NODEGROUP" \
              --arg ami "$AMI_TYPE" \
              --arg disk "$DISK_SIZE_GB" \
              --arg cluster_name "$CLUSTER_NAME" \
              --arg timestamp "$TIMESTAMP" \
              '{
                name: $name,
                ip_address: $ip,
                host_name: $name,
                short_description: ("EKS Node - " + $nodegroup),
                comments: ("Instance ID: " + $instance_id + "\nNode Group: " + $nodegroup + "\nKubernetes Version: " + $k8s_version + "\nAllocatable CPU: " + $alloc_cpu + "\nAllocatable Memory: " + $alloc_memory),
                operational_status: (if $state == "running" and $k8s_status == "True" then "1" else "2" end),
                cpu_count: $cpu_count,
                ram: $memory_mb,
                disk_space: $disk,
                os_version: $k8s_version,
                cluster_name: $cluster_name,
                u_instance_id: $instance_id,
                u_instance_type: $instance_type,
                u_availability_zone: $az,
                u_eks_state: $state,
                u_kubernetes_status: $k8s_status,
                u_nodegroup: $nodegroup,
                u_ami_type: $ami,
                u_last_discovered: $timestamp
              }')

            # Check if node exists (query by u_instance_id)
            EXISTING_NODE=$(curl -s -X GET \
              "${SERVICENOW_INSTANCE_URL}/api/now/table/cmdb_ci_server?sysparm_query=u_instance_id=$INSTANCE_ID&sysparm_limit=1" \
              -H "Authorization: Basic ${BASIC_AUTH}" \
              -H "Content-Type: application/json" 2>/dev/null || echo '{"result":[]}')

            NODE_SYS_ID=$(echo "$EXISTING_NODE" | jq -r '.result[0].sys_id // empty')

            if [ -n "$NODE_SYS_ID" ]; then
              # Update existing node
              curl -s -X PUT \
                "${SERVICENOW_INSTANCE_URL}/api/now/table/cmdb_ci_server/$NODE_SYS_ID" \
                -H "Authorization: Basic ${BASIC_AUTH}" \
                -H "Content-Type: application/json" \
                -d "$NODE_PAYLOAD" > /dev/null 2>&1
            else
              # Create new node
              NODE_RESPONSE=$(curl -s -X POST \
                "${SERVICENOW_INSTANCE_URL}/api/now/table/cmdb_ci_server" \
                -H "Authorization: Basic ${BASIC_AUTH}" \
                -H "Content-Type: application/json" \
                -d "$NODE_PAYLOAD" 2>/dev/null || echo '{"result":{"sys_id":""}}')

              NODE_SYS_ID=$(echo "$NODE_RESPONSE" | jq -r '.result.sys_id // empty')
            fi

            # Create relationship between cluster and node if node was created/updated successfully
            if [ -n "$NODE_SYS_ID" ]; then
              # Create relationship using cmdb_rel_ci table
              # Relationship type: "Contains::Contained by" (cluster contains nodes)
              REL_PAYLOAD=$(jq -n \
                --arg parent "$CLUSTER_SYS_ID" \
                --arg child "$NODE_SYS_ID" \
                '{
                  parent: $parent,
                  child: $child,
                  type: "d93304fb0a0a0b78006081a72ef08444"
                }')

              # Check if relationship already exists
              EXISTING_REL=$(curl -s -X GET \
                "${SERVICENOW_INSTANCE_URL}/api/now/table/cmdb_rel_ci?sysparm_query=parent=$CLUSTER_SYS_ID^child=$NODE_SYS_ID&sysparm_limit=1" \
                -H "Authorization: Basic ${BASIC_AUTH}" \
                -H "Content-Type: application/json" 2>/dev/null || echo '{"result":[]}')

              REL_EXISTS=$(echo "$EXISTING_REL" | jq -r '.result[0].sys_id // empty')

              if [ -z "$REL_EXISTS" ]; then
                # Create new relationship
                curl -s -X POST \
                  "${SERVICENOW_INSTANCE_URL}/api/now/table/cmdb_rel_ci" \
                  -H "Authorization: Basic ${BASIC_AUTH}" \
                  -H "Content-Type: application/json" \
                  -d "$REL_PAYLOAD" > /dev/null 2>&1
              fi
            fi

            NODE_COUNT=$((NODE_COUNT + 1))
          done <<< "$NODES"

          echo "- **EKS nodes updated**: $NODE_COUNT nodes" >> $GITHUB_STEP_SUMMARY
          echo "- **Relationships created**: Cluster ↔ Nodes" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: Upload microservices to ServiceNow CMDB
        if: ${{ env.SERVICENOW_PASSWORD != '' }}
        run: |
          # Check if CLUSTER_SYS_ID was set by previous step
          if [ -z "${CLUSTER_SYS_ID}" ]; then
            echo "⚠️ CLUSTER_SYS_ID not set, skipping microservices upload" >> $GITHUB_STEP_SUMMARY
            exit 0
          fi

          # Create Basic Auth header
          BASIC_AUTH=$(echo -n "${{ secrets.SERVICENOW_USERNAME }}:${{ secrets.SERVICENOW_PASSWORD }}" | base64)

          echo "Uploading microservices to ServiceNow CMDB..."

          # Read all services
          SERVICES=$(jq -c '.services[]' all-services.json)
          SERVICE_COUNT=0

          while IFS= read -r service; do
            NAME=$(echo "$service" | jq -r '.name')
            NAMESPACE=$(echo "$service" | jq -r '.namespace')
            ENV=$(echo "$service" | jq -r '.environment')
            REPLICAS=$(echo "$service" | jq -r '.replicas')
            READY_REPLICAS=$(echo "$service" | jq -r '.ready_replicas')
            IMAGE=$(echo "$service" | jq -r '.image')
            IMAGE_TAG=$(echo "$service" | jq -r '.image_tag')
            STATUS=$(echo "$service" | jq -r '.status')

            # Prepare service payload using jq with proper escaping
            TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
            SERVICE_PAYLOAD=$(echo "$service" | jq \
              --arg cluster_name "$CLUSTER_NAME" \
              --arg timestamp "$TIMESTAMP" \
              '{
                u_name: .name,
                u_namespace: .namespace,
                u_cluster_name: $cluster_name,
                u_replicas: (.replicas | tostring),
                u_ready_replicas: (.ready_replicas | tostring),
                u_image: .image,
                u_status: .status,
                u_language: .language
              }')

            # Check if service exists
            EXISTING_SERVICE=$(curl -s -X GET \
              "${SERVICENOW_INSTANCE_URL}/api/now/table/u_microservice?sysparm_query=u_name=$NAME^u_namespace=$NAMESPACE&sysparm_limit=1" \
              -H "Authorization: Basic ${BASIC_AUTH}" \
              -H "Content-Type: application/json" 2>/dev/null || echo '{"result":[]}')

            SERVICE_SYS_ID=$(echo "$EXISTING_SERVICE" | jq -r '.result[0].sys_id // empty')

            if [ -n "$SERVICE_SYS_ID" ]; then
              curl -s -X PUT \
                "${SERVICENOW_INSTANCE_URL}/api/now/table/u_microservice/$SERVICE_SYS_ID" \
                -H "Authorization: Basic ${BASIC_AUTH}" \
                -H "Content-Type: application/json" \
                -d "$SERVICE_PAYLOAD" > /dev/null 2>&1
            else
              curl -s -X POST \
                "${SERVICENOW_INSTANCE_URL}/api/now/table/u_microservice" \
                -H "Authorization: Basic ${BASIC_AUTH}" \
                -H "Content-Type: application/json" \
                -d "$SERVICE_PAYLOAD" > /dev/null 2>&1
            fi

            SERVICE_COUNT=$((SERVICE_COUNT + 1))
          done <<< "$SERVICES"

          echo "- **Microservices updated**: $SERVICE_COUNT services" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "✅ All microservices uploaded to CMDB" >> $GITHUB_STEP_SUMMARY

      - name: ServiceNow CMDB not configured
        if: ${{ env.SERVICENOW_PASSWORD == '' }}
        run: |
          echo "### ServiceNow CMDB Update" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "⚠️ ServiceNow CMDB integration not configured" >> $GITHUB_STEP_SUMMARY
          echo "Add \`SERVICENOW_PASSWORD\` secret to enable CMDB updates" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: Create discovery summary
        env:
          CLUSTER_ARN: ${{ steps.cluster-info.outputs.cluster_arn }}
          CLUSTER_VERSION: ${{ steps.cluster-info.outputs.cluster_version }}
          CLUSTER_STATUS: ${{ steps.cluster-info.outputs.cluster_status }}
          VPC_ID: ${{ steps.cluster-info.outputs.vpc_id }}
        run: |
          cat > discovery-summary.md << EOF
          # EKS Discovery Summary

          **Discovery Date**: $(date)
          **Cluster**: ${CLUSTER_NAME}
          **Region**: ${AWS_REGION}

          ## Cluster Information
          - **ARN**: ${CLUSTER_ARN}
          - **Version**: Kubernetes ${CLUSTER_VERSION}
          - **Status**: ${CLUSTER_STATUS}
          - **VPC**: ${VPC_ID}

          ## EKS Nodes Discovered
          EOF

          if [ -f all-nodes.json ]; then
            jq -r '.nodes[] | "- **\(.kubernetes_name)** (\(.instance_type)) - \(.private_ip) - \(.nodegroup) - \(.state)"' all-nodes.json >> discovery-summary.md
            TOTAL_NODES=$(jq '.nodes | length' all-nodes.json)
            echo "" >> discovery-summary.md
            echo "**Total nodes**: $TOTAL_NODES" >> discovery-summary.md
          fi

          echo "" >> discovery-summary.md
          echo "## Microservices Discovered" >> discovery-summary.md

          jq -r '.services[] | "- \(.name) [\(.environment)]: \(.ready_replicas)/\(.replicas) replicas - \(.status)"' all-services.json >> discovery-summary.md

          echo "" >> discovery-summary.md
          echo "## ServiceNow Integration" >> discovery-summary.md

          if [ -n "${SERVICENOW_PASSWORD}" ]; then
            echo "✅ Data uploaded to ServiceNow CMDB" >> discovery-summary.md
            echo "- **Cluster Record**: ${SERVICENOW_INSTANCE_URL}/nav_to.do?uri=u_eks_cluster_list.do" >> discovery-summary.md
            echo "- **EKS Nodes**: ${SERVICENOW_INSTANCE_URL}/nav_to.do?uri=cmdb_ci_server_list.do" >> discovery-summary.md
            echo "- **Microservices**: ${SERVICENOW_INSTANCE_URL}/nav_to.do?uri=u_microservice_list.do" >> discovery-summary.md
          else
            echo "⚠️ ServiceNow CMDB integration not configured" >> discovery-summary.md
          fi

          echo "" >> discovery-summary.md
          echo "---" >> discovery-summary.md
          echo "Discovery completed successfully ✅" >> discovery-summary.md

          cat discovery-summary.md

      - name: Upload summary as artifact
        uses: actions/upload-artifact@v4
        with:
          name: discovery-summary-${{ github.run_number }}
          path: |
            discovery-summary.md
            all-services.json
            all-nodes.json
            cluster.json
          retention-days: 30

      - name: Final summary
        run: |
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**View ServiceNow CMDB**:" >> $GITHUB_STEP_SUMMARY
          if [ -n "${SERVICENOW_PASSWORD}" ]; then
            echo "- [EKS Clusters](${SERVICENOW_INSTANCE_URL}/nav_to.do?uri=u_eks_cluster_list.do)" >> $GITHUB_STEP_SUMMARY
            echo "- [EKS Nodes](${SERVICENOW_INSTANCE_URL}/nav_to.do?uri=cmdb_ci_server_list.do)" >> $GITHUB_STEP_SUMMARY
            echo "- [Microservices](${SERVICENOW_INSTANCE_URL}/nav_to.do?uri=u_microservice_list.do)" >> $GITHUB_STEP_SUMMARY
          else
            echo "⚠️ Configure \`SERVICENOW_PASSWORD\` secret to enable CMDB integration" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Next Discovery**: Scheduled in 6 hours or run manually" >> $GITHUB_STEP_SUMMARY
