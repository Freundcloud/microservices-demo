# yamllint disable rule:line-length
name: "Deploy Application to EKS"

on:
  workflow_dispatch:
    inputs:
      cluster_name:
        description: 'EKS Cluster Name'
        required: false
        default: 'online-boutique'
      namespace:
        description: 'Kubernetes Namespace'
        required: false
        default: 'default'
  push:
    branches:
      - main
    paths:
      - 'src/**'
      - 'kubernetes-manifests/**'
      - 'release/kubernetes-manifests.yaml'
      - '.github/workflows/deploy-application.yaml'

permissions:
  contents: read
  id-token: write

env:
  AWS_REGION: eu-west-2
  CLUSTER_NAME: online-boutique

jobs:
  deploy-to-eks:
    name: Deploy to EKS
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig \
            --region ${{ env.AWS_REGION }} \
            --name ${{ github.event.inputs.cluster_name || env.CLUSTER_NAME }}

      - name: Verify EKS Connection
        run: |
          kubectl cluster-info
          kubectl get nodes

      - name: Create Namespace (if needed)
        run: |
          kubectl create namespace ${{ github.event.inputs.namespace || 'default' }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy Application
        run: |
          kubectl apply -f release/kubernetes-manifests.yaml \
            -n ${{ github.event.inputs.namespace || 'default' }}

      - name: Wait for Pods to be Ready
        run: |
          kubectl wait --for=condition=ready pods --all \
            -n ${{ github.event.inputs.namespace || 'default' }} \
            --timeout=300s

      - name: Get Deployment Status
        id: status
        run: |
          echo "### Deployment Status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          kubectl get deployments -n ${{ github.event.inputs.namespace || 'default' }} >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Pods" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          kubectl get pods -n ${{ github.event.inputs.namespace || 'default' }} >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

      - name: Get Services
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Services" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          kubectl get services -n ${{ github.event.inputs.namespace || 'default' }} >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

      - name: Create Ingress for Frontend
        run: |
          cat <<EOF | kubectl apply -f -
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: frontend-ingress
            namespace: ${{ github.event.inputs.namespace || 'default' }}
            annotations:
              alb.ingress.kubernetes.io/scheme: internet-facing
              alb.ingress.kubernetes.io/target-type: ip
              alb.ingress.kubernetes.io/healthcheck-path: /
          spec:
            ingressClassName: alb
            rules:
            - http:
                paths:
                - path: /
                  pathType: Prefix
                  backend:
                    service:
                      name: frontend
                      port:
                        number: 80
          EOF

      - name: Wait for Ingress
        run: |
          echo "Waiting for ALB to provision..."
          sleep 60
          kubectl get ingress frontend-ingress -n ${{ github.event.inputs.namespace || 'default' }}

      - name: Get Application URL
        id: get-url
        run: |
          INGRESS_HOST=$(kubectl get ingress frontend-ingress \
            -n ${{ github.event.inputs.namespace || 'default' }} \
            -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          echo "url=http://${INGRESS_HOST}" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Application URL" >> $GITHUB_STEP_SUMMARY
          echo "ðŸš€ Application is available at: http://${INGRESS_HOST}" >> $GITHUB_STEP_SUMMARY

      - name: Run Health Checks
        continue-on-error: true
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Health Checks" >> $GITHUB_STEP_SUMMARY
          SERVICES="emailservice checkoutservice recommendationservice frontend paymentservice productcatalogservice cartservice currencyservice shippingservice adservice"
          for service in $SERVICES; do
            STATUS=$(kubectl get pods -l app=$service -n ${{ github.event.inputs.namespace || 'default' }} -o jsonpath='{.items[0].status.phase}' 2>/dev/null || echo "Not Found")
            if [ "$STATUS" == "Running" ]; then
              echo "âœ… $service: $STATUS" >> $GITHUB_STEP_SUMMARY
            else
              echo "âŒ $service: $STATUS" >> $GITHUB_STEP_SUMMARY
            fi
          done

  # Optional: Send notification on deployment success
  notify-deployment:
    name: Notify Deployment Success
    needs: deploy-to-eks
    if: success()
    runs-on: ubuntu-latest

    steps:
      - name: Create Deployment Summary
        run: |
          echo "âœ… Successfully deployed Online Boutique to EKS" >> $GITHUB_STEP_SUMMARY
          echo "Cluster: ${{ github.event.inputs.cluster_name || env.CLUSTER_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "Region: ${{ env.AWS_REGION }}" >> $GITHUB_STEP_SUMMARY
          echo "Namespace: ${{ github.event.inputs.namespace || 'default' }}" >> $GITHUB_STEP_SUMMARY
